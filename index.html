<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dirt Bike Racing</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body {
      box-sizing: border-box;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      width: 100%;
    }

    body {
      font-family: 'Exo 2', 'Rajdhani', sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      overflow: hidden;
    }

    .game-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #87ceeb 0%, #f0e68c 70%, #daa520 100%);
    }

    .hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
    }

    .stats {
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border-radius: 12px;
      color: #fff;
      font-size: 16px;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .stats-row {
      display: flex;
      align-items: center;
      margin: 5px 0;
    }

    .stats-label {
      color: #ffd700;
      margin-right: 10px;
      font-weight: bold;
    }

    .controls {
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border-radius: 12px;
      color: #fff;
      font-size: 14px;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .control-item {
      margin: 5px 0;
    }

    .key {
      background: linear-gradient(145deg, #2a2a3e, #1a1a2e);
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      margin-right: 8px;
      border: 1px solid #ffd700;
      font-weight: bold;
      color: #ffd700;
    }

    .reset-button {
      background: linear-gradient(145deg, #ff4444, #cc0000);
      color: #fff;
      border: 2px solid #ffd700;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 15px;
      pointer-events: auto;
      transition: all 0.3s ease;
    }

    .reset-button:hover {
      background: linear-gradient(145deg, #ff6666, #ff0000);
      transform: scale(1.05);
    }

    .reset-button:active {
      transform: scale(0.95);
    }

    .title-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 5;
      background: rgba(0, 0, 0, 0.85);
      padding: 40px 60px;
      border-radius: 20px;
      border: 3px solid #ffd700;
      backdrop-filter: blur(15px);
    }

    .game-title {
      font-size: 56px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      margin-bottom: 20px;
      letter-spacing: 2px;
    }

    .start-instruction {
      font-size: 20px;
      color: #fff;
      margin-bottom: 10px;
    }

    .terrain-indicator {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 12px 30px;
      border-radius: 25px;
      color: #fff;
      font-size: 18px;
      font-weight: bold;
      border: 2px solid;
      backdrop-filter: blur(10px);
      z-index: 10;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .start-instruction {
      animation: pulse 2s infinite;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div class="game-container">
   <canvas id="gameCanvas"></canvas>
   <div class="hud">
    <div class="stats">
     <div class="stats-row"><span class="stats-label">Speed:</span> <span id="speedDisplay">0</span> km/h
     </div>
     <div class="stats-row"><span class="stats-label">Distance:</span> <span id="distanceDisplay">0</span> m
     </div>
     <div class="stats-row"><span class="stats-label">Airtime:</span> <span id="airtimeDisplay">0.0</span> s
     </div>
     <div class="stats-row"><span class="stats-label">Score:</span> <span id="scoreDisplay">0</span>
     </div>
    </div>
    <div class="controls">
     <div class="control-item">
      <span class="key">���</span> Gas
     </div>
     <div class="control-item">
      <span class="key">↓</span> Brake
     </div>
     <div class="control-item">
      <span class="key">←</span> Lean Back
     </div>
     <div class="control-item">
      <span class="key">→</span> Lean Forward
     </div>
     <div class="control-item">
      <span class="key">SPACE</span> Jump
     </div><button class="reset-button" id="resetButton">RESET TRACK</button>
    </div>
   </div>
   <div class="terrain-indicator" id="terrainIndicator">
    Desert
   </div>
   <div class="title-overlay" id="titleOverlay">
    <div class="game-title" id="gameTitle">
     DIRT BIKE RACING
    </div>
    <div class="start-instruction" id="instructionText">
     Press UP ARROW to start racing!
    </div>
   </div>
  </div>
  <script>
    const defaultConfig = {
      game_title: "DIRT BIKE RACING",
      instruction_text: "Press UP ARROW to start racing!"
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const keys = {};
    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
      if (!gameStarted && (e.key === 'ArrowUp' || e.key === 'Up')) {
        gameStarted = true;
        document.getElementById('titleOverlay').style.display = 'none';
      }
      if (e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault();
        if (bike.onGround) {
          bike.vy = -15;
          bike.onGround = false;
        }
      }
    });
    window.addEventListener('keyup', (e) => keys[e.key] = false);

    document.getElementById('resetButton').addEventListener('click', () => {
      bike.x = 200;
      bike.y = 300;
      bike.speed = 0;
      bike.vx = 0;
      bike.vy = 0;
      bike.rotation = 0;
      bike.totalAirtime = 0;
      bike.airtime = 0;
      score = 0;
      enemies = [];
      enemySpawnTimer = 0;
      cameraX = 0;
      terrainOffset = 0;
      terrainSegmentDistance = 0;
      currentTerrainIndex = 0;
      gameStarted = false;
      document.getElementById('titleOverlay').style.display = 'block';
      document.getElementById('terrainIndicator').textContent = terrainTypes[0].name;
      document.getElementById('terrainIndicator').style.borderColor = terrainTypes[0].color;
    });

    let gameStarted = false;
    let cameraX = 0;

    const bike = {
      x: 200,
      y: 400,
      width: 40,
      height: 25,
      speed: 0,
      rotation: 0,
      vx: 0,
      vy: 0,
      onGround: false,
      airtime: 0,
      totalAirtime: 0
    };

    let score = 0;
    let enemies = [];
    let enemySpawnTimer = 0;
    const ENEMY_SPAWN_INTERVAL = 180; // Spawn every 3 seconds at 60fps

    const terrainTypes = [
      { name: 'Desert', color: '#daa520', skyStart: '#87ceeb', skyEnd: '#f0e68c', obstacles: ['cactus', 'rock'] },
      { name: 'Forest', color: '#228b22', skyStart: '#6ba3d4', skyEnd: '#a8d5ba', obstacles: ['tree', 'log'] },
      { name: 'Street', color: '#4a4a4a', skyStart: '#87ceeb', skyEnd: '#b0c4de', obstacles: ['cone', 'sign'] }
    ];

    let currentTerrainIndex = 0;
    let terrainSegmentDistance = 0;
    const TERRAIN_SWITCH_DISTANCE = 2000;

    const terrain = [];
    const terrainSegments = 300;
    let terrainOffset = 0;

    function generateTerrain() {
      for (let i = 0; i < terrainSegments; i++) {
        const baseHeight = 400 + Math.sin(i * 0.03) * 100;
        const noise = Math.random() * 30 - 15;
        
        if (i % 40 === 20) {
          terrain.push({ x: i * 50, y: baseHeight - 100, type: 'jump' });
        } else if (i % 50 === 0 && Math.random() > 0.5) {
          terrain.push({ x: i * 50, y: baseHeight - 50, type: 'hill' });
        } else {
          terrain.push({ x: i * 50, y: baseHeight + noise, type: 'normal' });
        }
      }
    }

    generateTerrain();

    function extendTerrain(bikeX) {
      const lastTerrain = terrain[terrain.length - 1];
      if (bikeX > lastTerrain.x - 5000) {
        const startIndex = terrain.length;
        for (let i = 0; i < 100; i++) {
          const index = startIndex + i;
          const baseHeight = 400 + Math.sin(index * 0.03) * 100;
          const noise = Math.random() * 30 - 15;
          
          if (index % 40 === 20) {
            terrain.push({ x: index * 50, y: baseHeight - 100, type: 'jump' });
          } else if (index % 50 === 0 && Math.random() > 0.5) {
            terrain.push({ x: index * 50, y: baseHeight - 50, type: 'hill' });
          } else {
            terrain.push({ x: index * 50, y: baseHeight + noise, type: 'normal' });
          }
        }
      }
    }

    function spawnEnemy() {
      const spawnX = bike.x + canvas.width;
      const groundHeight = getTerrainHeightAt(spawnX);
      enemies.push({
        x: spawnX,
        y: groundHeight - 20,
        width: 40,
        height: 25,
        speed: bike.speed + 1 + Math.random() * 1,
        rotation: 0,
        vy: 0,
        onGround: false
      });
    }

    function updateEnemies() {
      enemySpawnTimer++;
      if (enemySpawnTimer >= ENEMY_SPAWN_INTERVAL && gameStarted) {
        spawnEnemy();
        enemySpawnTimer = 0;
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        // Apply stronger gravity to enemies too
        enemy.vy += 1.0;
        enemy.y += enemy.vy;
        
        // Move towards bike
        enemy.x -= enemy.speed;
        
        // Ground collision
        const groundHeight = getTerrainHeightAt(enemy.x);
        const groundAngle = getTerrainAngleAt(enemy.x);
        
        if (enemy.y >= groundHeight - enemy.height / 2) {
          enemy.y = groundHeight - enemy.height / 2;
          enemy.vy = 0;
          enemy.onGround = true;
          enemy.rotation = groundAngle * 0.8;
        } else {
          enemy.onGround = false;
        }
        
        // Remove off-screen enemies
        if (enemy.x < bike.x - canvas.width) {
          enemies.splice(i, 1);
          continue;
        }
        
        // Check collision with bike - enemies bump you instead of instant death
        const dx = bike.x - enemy.x;
        const dy = bike.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 30) {
          // Push bike away from enemy
          const angle = Math.atan2(dy, dx);
          bike.vx += Math.cos(angle) * 5;
          bike.vy -= 8;
          bike.speed = Math.max(bike.speed - 3, 0);
          
          // Remove enemy after collision
          enemies.splice(i, 1);
        }
      }
    }

    const obstacles = [];
    function generateObstacles() {
      const currentTerrain = terrainTypes[currentTerrainIndex];
      for (let i = obstacles.length; i < terrain.length; i += 15) {
        if (Math.random() > 0.6) {
          const obstacleType = currentTerrain.obstacles[Math.floor(Math.random() * currentTerrain.obstacles.length)];
          obstacles.push({
            x: terrain[i].x + Math.random() * 100,
            y: terrain[i].y,
            type: obstacleType
          });
        }
      }
    }
    generateObstacles();

    function getTerrainHeightAt(x) {
      const index = Math.floor((x + terrainOffset) / 50);
      if (index < 0 || index >= terrain.length - 1) return 400;
      
      const t1 = terrain[index];
      const t2 = terrain[index + 1];
      const progress = ((x + terrainOffset) % 50) / 50;
      
      return t1.y + (t2.y - t1.y) * progress;
    }

    function getTerrainAngleAt(x) {
      const index = Math.floor((x + terrainOffset) / 50);
      if (index < 0 || index >= terrain.length - 1) return 0;
      
      const t1 = terrain[index];
      const t2 = terrain[index + 1];
      
      return Math.atan2(t2.y - t1.y, 50);
    }

    function updatePhysics() {
      if (!gameStarted) return;

      extendTerrain(bike.x);
      updateEnemies();
      
      // Increase score while alive
      score += 1;

      const currentTerrain = terrainTypes[currentTerrainIndex];

      if (keys['ArrowUp'] || keys['Up']) {
        bike.speed += 0.5;
      }
      if (keys['ArrowDown'] || keys['Down']) {
        bike.speed -= 0.8;
      }

      bike.speed *= 0.99;
      bike.speed = Math.max(-5, Math.min(20, bike.speed));

      // Better lean controls - work in air and affect landing
      if (keys['ArrowLeft'] || keys['Left']) {
        bike.rotation -= 0.08;
      }
      if (keys['ArrowRight'] || keys['Right']) {
        bike.rotation += 0.08;
      }

      // Limit rotation more strictly
      bike.rotation = Math.max(-0.6, Math.min(0.6, bike.rotation));
      
      // Rotation dampening when on ground
      if (bike.onGround) {
        bike.rotation *= 0.85;
      }

      bike.vx = bike.speed;
      
      // Apply stronger gravity for better landing
      bike.vy += 1.0;

      bike.x += bike.vx;
      bike.y += bike.vy;

      cameraX = bike.x - canvas.width / 3;
      terrainOffset = cameraX;

      terrainSegmentDistance += Math.abs(bike.vx);
      if (terrainSegmentDistance > TERRAIN_SWITCH_DISTANCE) {
        currentTerrainIndex = (currentTerrainIndex + 1) % terrainTypes.length;
        terrainSegmentDistance = 0;
        document.getElementById('terrainIndicator').textContent = currentTerrain.name;
        document.getElementById('terrainIndicator').style.borderColor = currentTerrain.color;
      }

      // Check ground collision for both wheels
      const frontX = bike.x + Math.cos(bike.rotation) * 20;
      const rearX = bike.x - Math.cos(bike.rotation) * 20;
      const frontGroundHeight = getTerrainHeightAt(frontX);
      const rearGroundHeight = getTerrainHeightAt(rearX);
      const centerGroundHeight = getTerrainHeightAt(bike.x);
      const groundAngle = getTerrainAngleAt(bike.x);

      // Check if bike center is at or below ground level
      const bikeBottomY = bike.y + Math.sin(bike.rotation) * bike.height / 2;
      
      if (bike.y >= centerGroundHeight - bike.height / 2) {
        bike.y = centerGroundHeight - bike.height / 2;
        bike.vy = 0;
        bike.onGround = true;
        bike.rotation = groundAngle * 0.8;

        if (bike.airtime > 0) {
          bike.totalAirtime += bike.airtime;
          bike.airtime = 0;
        }
      } else {
        bike.onGround = false;
        bike.airtime += 0.016;
      }

      if (bike.y > canvas.height + 100) {
        bike.x = 200;
        bike.y = 300;
        bike.speed = 0;
        bike.vx = 0;
        bike.vy = 0;
        bike.rotation = 0;
      }
    }

    function drawSky() {
      const currentTerrain = terrainTypes[currentTerrainIndex];
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, currentTerrain.skyStart);
      gradient.addColorStop(1, currentTerrain.skyEnd);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw background scenery based on terrain type
      if (currentTerrainIndex === 0) {
        // Desert: Pyramids, camels, palm trees
        drawDesertBackground();
      } else if (currentTerrainIndex === 1) {
        // Forest: Trees, plants, vines
        drawForestBackground();
      } else if (currentTerrainIndex === 2) {
        // Street: Cityscape, buildings, high-rises
        drawCityBackground();
      }
    }
    
    function drawDesertBackground() {
      // Pyramids in far background
      const pyramidBaseX = ((cameraX * 0.1) % 800) - 400;
      
      ctx.fillStyle = 'rgba(184, 134, 11, 0.6)';
      ctx.beginPath();
      ctx.moveTo(pyramidBaseX + 100, 350);
      ctx.lineTo(pyramidBaseX + 200, 250);
      ctx.lineTo(pyramidBaseX + 300, 350);
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = 'rgba(160, 120, 10, 0.6)';
      ctx.beginPath();
      ctx.moveTo(pyramidBaseX + 400, 350);
      ctx.lineTo(pyramidBaseX + 480, 280);
      ctx.lineTo(pyramidBaseX + 560, 350);
      ctx.closePath();
      ctx.fill();
      
      // Palm trees
      for (let i = 0; i < 5; i++) {
        const palmX = ((cameraX * 0.3 + i * 300) % canvas.width) - 100;
        const palmY = 320;
        
        // Trunk
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(palmX, palmY, 12, 80);
        
        // Leaves
        ctx.strokeStyle = '#228b22';
        ctx.lineWidth = 4;
        for (let j = 0; j < 6; j++) {
          const angle = (Math.PI * 2 / 6) * j;
          ctx.beginPath();
          ctx.moveTo(palmX + 6, palmY);
          ctx.quadraticCurveTo(
            palmX + 6 + Math.cos(angle) * 20,
            palmY - 20,
            palmX + 6 + Math.cos(angle) * 35,
            palmY - 30
          );
          ctx.stroke();
        }
      }
      
      // Camels
      const camelX = ((cameraX * 0.2) % canvas.width) + 200;
      ctx.fillStyle = '#c19a6b';
      ctx.beginPath();
      ctx.ellipse(camelX, 340, 30, 20, 0, 0, Math.PI * 2);
      ctx.fill();
      // Hump
      ctx.beginPath();
      ctx.arc(camelX - 5, 330, 12, 0, Math.PI * 2);
      ctx.fill();
      // Head
      ctx.beginPath();
      ctx.arc(camelX + 25, 335, 8, 0, Math.PI * 2);
      ctx.fill();
      // Legs
      ctx.fillRect(camelX - 15, 355, 4, 20);
      ctx.fillRect(camelX + 10, 355, 4, 20);
    }
    
    function drawForestBackground() {
      // Background trees
      for (let i = 0; i < 8; i++) {
        const treeX = ((cameraX * 0.15 + i * 200) % canvas.width) - 100;
        const treeY = 280 + Math.sin(i) * 20;
        
        // Tree trunk
        ctx.fillStyle = 'rgba(74, 37, 17, 0.7)';
        ctx.fillRect(treeX, treeY, 15, 120);
        
        // Tree foliage
        ctx.fillStyle = 'rgba(34, 139, 34, 0.7)';
        ctx.beginPath();
        ctx.arc(treeX + 7, treeY, 35, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(treeX - 10, treeY + 15, 30, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(treeX + 24, treeY + 15, 30, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Plants and bushes
      for (let i = 0; i < 10; i++) {
        const plantX = ((cameraX * 0.25 + i * 150) % canvas.width) - 50;
        const plantY = 360;
        
        ctx.fillStyle = 'rgba(50, 150, 50, 0.8)';
        ctx.beginPath();
        ctx.ellipse(plantX, plantY, 20, 15, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Vines
      ctx.strokeStyle = 'rgba(85, 107, 47, 0.6)';
      ctx.lineWidth = 3;
      for (let i = 0; i < 4; i++) {
        const vineX = ((cameraX * 0.1 + i * 250) % canvas.width);
        ctx.beginPath();
        ctx.moveTo(vineX, 100);
        ctx.quadraticCurveTo(vineX + 20, 200, vineX - 10, 300);
        ctx.stroke();
        
        // Leaves on vines
        ctx.fillStyle = 'rgba(34, 139, 34, 0.7)';
        for (let j = 0; j < 5; j++) {
          const leafY = 120 + j * 40;
          ctx.beginPath();
          ctx.ellipse(vineX + (j % 2 === 0 ? 10 : -10), leafY, 8, 12, Math.PI / 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    
    function drawCityBackground() {
      // Cityscape silhouette
      const buildings = [
        { x: 0, width: 80, height: 150, windows: true },
        { x: 85, width: 60, height: 200, windows: true },
        { x: 150, width: 90, height: 180, windows: true },
        { x: 245, width: 70, height: 220, windows: true },
        { x: 320, width: 100, height: 160, windows: true },
        { x: 425, width: 65, height: 240, windows: true },
        { x: 495, width: 85, height: 190, windows: true },
        { x: 585, width: 75, height: 170, windows: true },
        { x: 665, width: 95, height: 210, windows: true }
      ];
      
      buildings.forEach(building => {
        const buildingX = ((cameraX * 0.1 + building.x) % (canvas.width + 200)) - 100;
        const buildingY = 350 - building.height;
        
        // Building body
        ctx.fillStyle = 'rgba(70, 70, 90, 0.7)';
        ctx.fillRect(buildingX, buildingY, building.width, building.height);
        
        // Building outline
        ctx.strokeStyle = 'rgba(50, 50, 70, 0.9)';
        ctx.lineWidth = 2;
        ctx.strokeRect(buildingX, buildingY, building.width, building.height);
        
        // Windows
        if (building.windows) {
          ctx.fillStyle = 'rgba(255, 255, 200, 0.6)';
          const windowRows = Math.floor(building.height / 20);
          const windowCols = Math.floor(building.width / 15);
          
          for (let row = 0; row < windowRows; row++) {
            for (let col = 0; col < windowCols; col++) {
              if (Math.random() > 0.3) {
                ctx.fillRect(
                  buildingX + 5 + col * 15,
                  buildingY + 5 + row * 20,
                  8,
                  12
                );
              }
            }
          }
        }
        
        // Rooftop details
        ctx.fillStyle = 'rgba(90, 90, 110, 0.8)';
        if (building.height > 180) {
          ctx.fillRect(buildingX + building.width / 3, buildingY - 15, building.width / 3, 15);
        }
      });
      
      // Landmark tower in distance
      const towerX = ((cameraX * 0.05) % canvas.width) + canvas.width / 2;
      ctx.fillStyle = 'rgba(100, 100, 120, 0.5)';
      ctx.fillRect(towerX, 180, 30, 170);
      ctx.beginPath();
      ctx.moveTo(towerX, 180);
      ctx.lineTo(towerX + 15, 150);
      ctx.lineTo(towerX + 30, 180);
      ctx.closePath();
      ctx.fill();
      
      // Antenna on top
      ctx.strokeStyle = 'rgba(80, 80, 100, 0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(towerX + 15, 150);
      ctx.lineTo(towerX + 15, 120);
      ctx.stroke();
    }

    function drawTerrain() {
      const currentTerrain = terrainTypes[currentTerrainIndex];
      
      ctx.fillStyle = currentTerrain.color;
      ctx.beginPath();
      ctx.moveTo(-100, canvas.height);
      
      for (let i = 0; i < terrain.length; i++) {
        const screenX = terrain[i].x - cameraX;
        if (screenX > -100 && screenX < canvas.width + 100) {
          ctx.lineTo(screenX, terrain[i].y);
        }
      }
      
      ctx.lineTo(canvas.width + 100, canvas.height);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      for (let i = 0; i < terrain.length; i++) {
        const screenX = terrain[i].x - cameraX;
        if (screenX > -100 && screenX < canvas.width + 100) {
          if (i === 0) {
            ctx.moveTo(screenX, terrain[i].y);
          } else {
            ctx.lineTo(screenX, terrain[i].y);
          }
        }
      }
      ctx.stroke();
    }

    function drawObstacles() {
      const currentTerrain = terrainTypes[currentTerrainIndex];
      
      obstacles.forEach(obstacle => {
        const screenX = obstacle.x - cameraX;
        if (screenX > -100 && screenX < canvas.width + 100) {
          ctx.save();
          ctx.translate(screenX, obstacle.y);
          
          if (obstacle.type === 'cactus') {
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(-5, -40, 10, 40);
            ctx.fillRect(-15, -25, 10, 3);
            ctx.fillRect(5, -30, 10, 3);
          } else if (obstacle.type === 'tree') {
            ctx.fillStyle = '#4a2511';
            ctx.fillRect(-5, -50, 10, 50);
            ctx.fillStyle = '#1a5d1a';
            ctx.beginPath();
            ctx.arc(0, -50, 20, 0, Math.PI * 2);
            ctx.fill();
          } else if (obstacle.type === 'rock') {
            ctx.fillStyle = '#696969';
            ctx.beginPath();
            ctx.ellipse(0, -10, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();
          } else if (obstacle.type === 'cone') {
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(-10, 0);
            ctx.lineTo(10, 0);
            ctx.closePath();
            ctx.fill();
          } else if (obstacle.type === 'sign') {
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-2, -40, 4, 40);
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(-12, -40, 24, 20);
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('!', 0, -26);
          } else if (obstacle.type === 'log') {
            ctx.fillStyle = '#654321';
            ctx.fillRect(-20, -8, 40, 8);
          }
          
          ctx.restore();
        }
      });
    }

    function drawBike() {
      ctx.save();
      ctx.translate(bike.x - cameraX, bike.y);
      ctx.rotate(bike.rotation);

      ctx.fillStyle = '#c0c0c0';
      ctx.beginPath();
      ctx.arc(-15, 10, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(15, 10, 8, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(-15, 10, 8, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(15, 10, 8, 0, Math.PI * 2);
      ctx.stroke();

      ctx.fillStyle = '#ff0000';
      ctx.fillRect(-20, -5, 40, 10);
      
      ctx.fillStyle = '#000';
      ctx.fillRect(-10, -10, 3, 5);
      ctx.fillRect(7, -10, 3, 5);

      ctx.fillStyle = '#ffa500';
      ctx.beginPath();
      ctx.arc(-5, -8, 6, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawEnemies() {
      enemies.forEach(enemy => {
        ctx.save();
        ctx.translate(enemy.x - cameraX, enemy.y);
        ctx.rotate(enemy.rotation);

        // Wheels
        ctx.fillStyle = '#404040';
        ctx.beginPath();
        ctx.arc(-15, 10, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(15, 10, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(-15, 10, 8, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(15, 10, 8, 0, Math.PI * 2);
        ctx.stroke();

        // Body (black for enemy)
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(-20, -5, 40, 10);
        
        // Handlebars
        ctx.fillStyle = '#333';
        ctx.fillRect(-10, -10, 3, 5);
        ctx.fillRect(7, -10, 3, 5);

        // Rider head (red for enemy)
        ctx.fillStyle = '#cc0000';
        ctx.beginPath();
        ctx.arc(-5, -8, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      });
    }

    function updateHUD() {
      document.getElementById('speedDisplay').textContent = Math.round(Math.abs(bike.speed) * 10);
      document.getElementById('distanceDisplay').textContent = Math.round(bike.x);
      document.getElementById('airtimeDisplay').textContent = bike.totalAirtime.toFixed(1);
      document.getElementById('scoreDisplay').textContent = score;
    }

    function gameLoop() {
      updatePhysics();
      
      drawSky();
      drawTerrain();
      drawObstacles();
      drawEnemies();
      drawBike();
      
      updateHUD();
      
      requestAnimationFrame(gameLoop);
    }

    gameLoop();

    async function onConfigChange(config) {
      const gameTitle = config.game_title || defaultConfig.game_title;
      const instructionText = config.instruction_text || defaultConfig.instruction_text;
      
      document.getElementById('gameTitle').textContent = gameTitle;
      document.getElementById('instructionText').textContent = instructionText;
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig: defaultConfig,
        onConfigChange: onConfigChange,
        mapToCapabilities: (config) => ({
          recolorables: [],
          borderables: [],
          fontEditable: undefined,
          fontSizeable: undefined
        }),
        mapToEditPanelValues: (config) => new Map([
          ["game_title", config.game_title || defaultConfig.game_title],
          ["instruction_text", config.instruction_text || defaultConfig.instruction_text]
        ])
      });
    }
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9c5471946528435b',t:'MTc2OTY0NDc2Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
